<!DOCTYPE html>
<html lang="en">
<head>
</head>
<body>
    <style>
        html, body, canvas {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
        }

        canvas {
            display: block;
        }

        p {
            position: fixed;
            margin: 0;
            padding: 0;
            top: 10px;
            left: 50%;
            text-align: center;
            transform: translateX(-50%);
        }
    </style>
    <canvas></canvas>
    <p>hello</p>
    <script>
        const canvas = document.querySelector('canvas');
        const context = canvas.getContext("2d");
        const info = document.querySelector('p');
        const rows = parseInt(window.prompt("rows?", "10"))?? 10;
        const columns = parseInt(window.prompt("columns?", "15"))?? 15;
        const cells = [];
        const maxTemp = 100;
        let G = 0.05;
        let mc = 1;

        let mouse;
        let mouseDown = false;
        canvas.addEventListener("mousedown", e => {
            mouse = e;
            mouseDown = true;
        });

        canvas.addEventListener("mousemove", e => {
            mouse = e;
        });

        canvas.addEventListener("mouseup", e => {
            mouseDown = false;
        });

        canvas.addEventListener("contextmenu", (e) => {
            e.preventDefault();
        });


        for (let i = 0; i < rows; i++) {
            const row = [];
            for (let j = 0; j < columns; j++) {
                row.push(parseInt(Math.random() * maxTemp));
            }
            cells.push(row);
        }
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);


        let heatCalculationCallback = () => {};
        document.addEventListener("keydown", e => {
            if (e.key != " ") return;
            if (heatCalculationCallback == balanceHeat) {
                heatCalculationCallback = () => {};
            } else {
                heatCalculationCallback = balanceHeat;
            }
        })


        function balanceHeat(deltaT) {
            const deltaCells = Array.from({ length: rows }, () => Array(columns).fill(0));

            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < columns; j++) {
                    const temp = cells[i][j];

                    // represented (y, x) for (i, j)
                    const neighbors = [
                        [0, 1],
                        [1, -1], [1, 0], [1, 1]
                    ];

                    // A to B then B to A, double deltaTemp which is BAD!!!!!!!!!!!!!!!!!!!!!!!!!!
                    for (const [di, dj] of neighbors) {
                        if (i + di < 0 || i + di >= rows || j + dj < 0 || j + dj >= columns) continue;
                        deltaCells[i][j] -= G * (temp - cells[i + di][j + dj]);
                        deltaCells[i + di][j + dj] += G * (temp - cells[i + di][j + dj])
                    }
                }
            }

            return deltaCells;
        }

        function updateHeat(deltaT) {
            deltaT = Math.min(deltaT, 0.2);
            const deltaCells = heatCalculationCallback(deltaT)?? Array.from({ length: rows }, () => Array(columns).fill(0));
            let totalHeat = 0;

            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < columns; j++) {
                    cells[i][j] += parseInt(Math.min(maxTemp, Math.max(deltaCells[i][j] * deltaT / mc, -maxTemp)) * 1000) / 1000;
                    totalHeat += cells[i][j];
                }
            }

            return [Math.round(totalHeat), Math.round(totalHeat / (rows * columns))];
        }

        function draw(deltaT) {
            let [totalHeat, averageHeat] = updateHeat(deltaT);
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < columns; j++) {
                    context.fillStyle = `oklch(${Math.min(50, cells[i][j] * 333 / maxTemp)}% 0.3 ${Math.max(0, (1 - (cells[i][j] / maxTemp)) * 235 + 20)})`;
                    context.fillRect(j * (innerWidth / columns), i * (innerHeight / rows), innerWidth / columns, innerHeight / rows);
                }
            }

            const rect = canvas.getBoundingClientRect();
            if (mouse) {
                const x = Math.floor((mouse.clientX - rect.left) / canvas.width * columns);
                const y = Math.floor((mouse.clientY - rect.top) / canvas.height * rows);
    
                info.innerText = `Average heat: ${averageHeat}° (total: ${totalHeat}°)\nCell (${x + 1}, ${y + 1}): ${Math.floor(cells[y][x])}°`;

                if (mouseDown) {
                    cells[y][x] += (mouse.buttons & 1)? 2 : -2;
                }
            } 

            requestAnimationFrame(draw);
        }

        requestAnimationFrame(draw);
    </script>
</body>
</html>